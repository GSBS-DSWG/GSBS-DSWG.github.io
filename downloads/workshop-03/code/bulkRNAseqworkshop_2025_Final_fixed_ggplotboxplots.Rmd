---
title: 'Bulk RNAseqworkshop: 10.16.2025'
author: 'Dr. Aatish Thennavan'
output: html_document
---

The goal of this workshop is to provide an introduction to analysis of bulk RNA-seq data

## Sample data
Our sample data comprises paired-end RNA-seq libraries from human lung cancer samples (Deng et al, 2021, *Nature Cancer*, PMID: 34142094)

## Loading required R libraries
First, install the R libraries that will be used for today's analyses:
```{r,quietly = TRUE}
# CRAN packages
cran_packages <- c("tidyverse","ggrepel","pheatmap","dplyr","stats","FactoMineR","factoextra", "gplots", "AnnotationDbi", "org.Hs.eg.db", "RColorBrewer")

for (pkg in cran_packages) {
  if (!requireNamespace(pkg, quietly = TRUE)) {
    install.packages(pkg)
  }
}

if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

bioc_packages <- c("limma","edgeR","DESeq2","ggplot2","dplyr", "msigdbr","fgsea", "Glimma", "EnhancedVolcano", "GSVA", "GSEABase","clusterProfiler","enrichplot","reshape2")

for (pkg in bioc_packages) {
  if (!requireNamespace(pkg, quietly = TRUE)) {
    BiocManager::install(pkg)
  }
}
```

Then load them:

```{r, echo=TRUE}
library(limma)
library(edgeR)
library(tidyverse)
library(DESeq2)
library(ggplot2)
library(ggrepel)
library(gplots)
library(stats)
library(pheatmap)
library(msigdbr)
library(fgsea)
library(FactoMineR)
library(factoextra)
library(Glimma)
library(EnhancedVolcano)
library(AnnotationDbi)
library(org.Hs.eg.db)
library(GSVA)
library(GSEABase)
library(clusterProfiler)
library(enrichplot)
library(RColorBrewer)
library(reshape2)
```

### 1. load gene-level abundance table
Set working directory for input and output files and load in the gene count matrix file. First we will examine the Raw count matrix input file. This file is in the classical count matrix output format after running the STAR-SALMON RNA mapping and quantification pipeline 

```{r setup, include=FALSE}
#knitr::opts_knit$set(root.dir = "~/Downloads/TCGA_LUADpaper/")   ###Change this to the directory where your files are
counttable <- read.table("data/TCGA_LUAD_KLvsKPgenematrix_forDESeq.txt", sep="\t",header = TRUE, row.names = 1)
counttable[1:10,1:6]
#View(counttable)

#Q. How are the genes annotated? 
#Q. How many genes are in the count matrix?

#Cleaning the raw matrix - Removing the rows without any HUGO gene symbols
#Removing decimal values

Counttablesubset <- counttable[!grepl("\\?", rownames(counttable)), ]
Counttablesubset<- round(Counttablesubset)

```


### 2. Let's explore the raw RNA count matrix file
This chunk of code helps you do basic filtering for low expressed genes and do our first normalization on library size. We will also use log transformation to scale the data

```{r plot-histogram, message=FALSE, warning=FALSE}
#convert the counts table to a matrix
Counttablesubset <- as.matrix(Counttablesubset)

#Plot and view the overall gene count distribution for one sample
#ggplot(Counttablesubset) + geom_histogram(aes(x = TCGA.55.7914.01A.11R.2170.07), #stat = "bin", bins = 200) + xlim(-5, 500)  + xlab("Raw expression counts") +
#ylab("Number of genes")

#Log Normalization and filtering of low expressed genes
myCPM <- cpm(Counttablesubset, log = TRUE)
myCPM[1:5,1:5]
thresh <- myCPM > 0.5
thresh[1:5,1:5]

#Keep meaningful genes with that are present in at least 2 samples
keep <- rowSums(thresh) >= 2

#Q. How many genes are filtered out at this threshold?

#Create the filtered count matrix for raw counts
Counttable.filtered<-Counttablesubset[keep, ]
#Create the filtered count matrix for log transformed data
Counttable.filtered.log<-myCPM[keep, ]

#Plot the final filtered RNA counts per sample
barplot(Counttable.filtered,names=colnames(Counttable.filtered),las=2)
title("Library sizes")

#Plot and view boxplot of unnormalized data on log transformed data
boxplot(Counttable.filtered.log, xlab="SampleIds", ylab="Log2 counts per million",las=2)
abline(h=median(Counttable.filtered),col="blue")
title("Boxplots of logCPMs (unnormalised)")

```

```{r plot-ggplot}
##ggplot version
Rawmatrix.logcountst<-as.data.frame(t(Counttable.filtered.log))
Rawmatrix.logcountst<-data.frame(Samples = row.names(Rawmatrix.logcountst), Rawmatrix.logcountst, row.names = NULL)
Rawmatrix.melt<-melt(Rawmatrix.logcountst)
library(reshape2)
#Plotting unnormalized data using ggplot2
q<-ggplot(Rawmatrix.melt, aes(x=Samples, y=value)) +geom_boxplot(fill="steelblue")+ theme_minimal()+labs(title="Unnormalized data",x ="SampleId", y = "Rawcounts")+stat_summary(fun = median, geom = "line", aes(group = 1), color = "red", linetype = "dashed")
q+theme(axis.text.x = element_text(angle = 60, hjust=1)) #ylim(0,5000)

```

### 3. Load sample info and introduction to bulkRNAseq objects (DGE object for edgeR) and (DESeq2 object for DESeq2))
For most bulk RNAseq analysis you will need a file that contains sample info for all the samples. The variables in this file will be used to specify groupings for dimension reduction and creating particular linear contrasts for differential gene expression analysis. We will need this file to create the DGE or DESeq2 objects

```{r read metadata, include=FALSE}
#knitr::opts_knit$set(root.dir = "~/Downloads/TCGA_LUADpaper/")  ###Don't forget to change this!!
sample_info <- read.table("data/TCGA_LUAD_KLvsKPannotation_forDESeq.txt",header = TRUE, stringsAsFactors=FALSE, row.names = 1)

#For edgeR
DGE=DGEList(Counttable.filtered,samples=rownames(sample_info),group=sample_info$Condition)
#For DESeq2 (DESeq2 will perform it's own filtering)
#The order of samples need to match in both the raw matrix and annotation file
all(rownames(sample_info) == colnames(Counttablesubset))
dds <- DESeqDataSetFromMatrix(countData = Counttablesubset,
colData = sample_info,
design = ~Condition)

```

### 4. Normalization
We will explore three different types of normalization: 1) Upper quantile normalization, 2) Trimmed mean of M-values (TMM) used in edge R and 3) variance stabilization transformation (VST) in DESeq2

```{r normalization, include=FALSE}
##UQ normalization - source this code chunk
quartileNorm<- function(x,y=NA){
  uqs<- apply(x,2,function(x){ quantile(x[x>0 & !is.na(x)],0.75)})
  if(is.na(y)){
    y<- median(uqs)
  }
  x.norm <- t(apply(x,1,function(x,y){x*y},y/uqs))
  dimnames(x.norm)<- dimnames(x)
  return(x.norm)
}

#Create a matrix for UQN
CounttablesubsetforUQ<-Counttable.filtered
rownames(CounttablesubsetforUQ)<-NULL
colnames(CounttablesubsetforUQ)<-NULL
Counttable.norm <- quartileNorm(CounttablesubsetforUQ)
rownames(Counttable.norm)<-rownames(Counttable.filtered)
colnames(Counttable.norm)<-colnames(Counttable.filtered)
Counttable.norm<-log(Counttable.norm)
Counttable.norm[Counttable.norm=='-Inf'] <- 0

#View the UQ normalized result
boxplot(Counttable.norm, xlab="SampleIds", ylab="UQN counts",las=2)
abline(h=median(Counttable.norm),col="blue")
title("Boxplots of UQN count data (Normalised)")

##TMM Normalization
DGE<-calcNormFactors(DGE,method =c("TMM"))
design <- model.matrix(~ 0 + group, DGE$samples)
v <- voom(DGE,design,plot = TRUE)

#View the TMM normalized result
boxplot(v$E, xlab="SampleIds", ylab="TMM counts",las=2)
abline(h=median(v$E),col="blue")
title("Boxplots of TMM count data (Normalised)")

##DESeq2 Normalization and visualization
vsd <- vst(dds,blind=TRUE)
vst_normalized_counts <- assay(vsd) #Thus is the rlog transformed data
#We now do the DESeq2 size factor calculations and normalization
dds <- estimateSizeFactors(dds)
se <- SummarizedExperiment(log2(counts(dds, normalized=TRUE) + 1),
                           colData=colData(dds))
se_normalized_counts <- assay(se)

#View the DESeq2 normalized data
boxplot(se_normalized_counts, xlab="SampleIds", ylab="VST counts",las=2)
abline(h=median(se_normalized_counts),col="blue")
title("Boxplots of VST count data (Normalised)")

```

### 6. Dimension reductionality - PCA visualizationand heirarchical clustering
Using normalized data we will now identify major groups or clusters in our data

```{r dimension reductionality, include=FALSE}

##Generating PCA plots and examining them 

#Using EdgeR DGE object
tempvals<-sample_info$Sample_name
popvals<-sample_info$Tumor_type
mds<-plotMDS(DGE,top=500,plot=FALSE,gene.selection="common")
mds_dataframe <-cbind(rownames(sample_info),sample_info$Condition,mds$x,mds$y)
colnames(mds_dataframe) <-c("sample","Group","pc1","pc2")
mds_dataframe <- as_tibble(mds_dataframe) %>% mutate(across(c(pc1, pc2), as.numeric))

mds_plot <- mds_dataframe %>% ggplot(aes(x=pc1,y=pc2,color=Group)) +
            geom_point(size=3) +
            xlab("Principal coordinate 1") +
            ylab("Principal coordinate 2") +
            geom_text_repel(aes(label = sample), size=3)
print(mds_plot)

##Using DESeq2 object

plotPCA( DESeqTransform( se ), intgroup = c("Condition"))
#Let's clean it up
plotPCA( DESeqTransform( se ), intgroup = c("Condition"))+ geom_text_repel(aes(label = name))+theme_classic()

#Q. What are some inferences we can get from the PCA plot?

##Let's extract other PCs as well and see what information they can contribute
pca <- prcomp(t(se_normalized_counts))
df <- cbind(sample_info, pca$x)
df$name<-rownames(df)
df[1:5,1:5]
ggplot(df,aes(x=PC1, y=PC2)) + geom_point(aes(color = Condition))+ geom_text_repel(aes(label = name))+theme_classic()
#Change PCs to PC3 and PC4 at x and y coordinates and see
ggplot(df,aes(x=PC3, y=PC4)) + geom_point(aes(color = Condition))+ geom_text_repel(aes(label = name))+theme_classic()

#How much variance in my data is captured by PC1 and PC2
res.pca <- PCA(se_normalized_counts, graph = FALSE)
eig.val <- get_eigenvalue(res.pca)
fviz_eig(res.pca, addlabels = TRUE, ylim = c(0, 50))

#Using Glimma
glimmaMDS(DGE)

##Generating hierarchical clustering heatmaps - We will use the top 50 most variable genes to make this heatmap
variable.genes <- apply(vst_normalized_counts, 1, var)
selectedgenes <- names(sort(variable.genes, decreasing=TRUE))[1:50]
head(selectedgenes)
highly_variablegenes <- vst_normalized_counts[selectedgenes,]

col.cell <- ifelse(sample_info$Condition == "KL", "red", "darkblue")

mypalette <- brewer.pal(8,"RdYlGn")
morecols <- colorRampPalette(mypalette)
heatmap.2(highly_variablegenes,col=rev(morecols(50)),trace="none", main="Top 50 most variable genes across samples",ColSideColors=col.cell,scale="row")

```

There is a separation between KL and KP samples, but it's not very distinct with 1 or 2 possible sample intermixing within groups indicating potential outliers that can be removed before DE gene analysis. 

## 7 Differential gene analysis - Identify genes that are different between my conditions
We will use both limma from edgeR (linear model and emperical bayes) and DESeq2 (linear model and Wald's test) to get DE genes. We will also do adjustments for false discovery rate to identify truly significant genes

```{r DE Gene analysis, include=FALSE}

##Using DESeq2
dds <- DESeq(dds) 

#Q. What results does it show you if you don't specify contrasts - check resultsNames(dds)

#Specify contrast for comparison you want. e.g. I want specifically genes in KL 
DESeq.Results <- results(dds, contrast=c("Condition", "KL", "KP"),independentFiltering=TRUE, alpha=0.05, pAdjustMethod="BH") #You can set parallel = TRUE if on mac

#Get the DE gene table
resOrdered <- DESeq.Results[order(DESeq.Results$padj),]
sig <- resOrdered[!is.na(resOrdered$padj) &
resOrdered$padj<0.05 &
abs(resOrdered$log2FoldChange)>=1,]
head(sig)
results = as.data.frame(dplyr::mutate(as.data.frame(resOrdered), sig=ifelse(resOrdered$padj<0.05, "FDR<0.05", "Not Sig")), row.names=rownames(resOrdered))
#write out the DE gene table
write.table(results, "KLvsKP_DESeq2gene.txt", sep="\t", col.names = NA)

##Visualize the results as a volcano plot
s = ggplot2::ggplot(results, ggplot2::aes(log2FoldChange, -log10(pvalue))) +
ggplot2::geom_point(ggplot2::aes(col = sig)) +
ggplot2::scale_color_manual(values = c("red", "black")) +
ggplot2::ggtitle("Volcano Plot of DESeq2 analysis")
s + ggrepel::geom_text_repel(data=results[1:10, ], ggplot2::aes(label=rownames(results[1:10, ])))

```

Let's make a better publication worthy volcano plot

```{r EnhancedVolcano plot, include=FALSE}

#Separating ENTREZ GeneIDs and HUGO gene symbols
all_genes_SYMBOL<-results
all_genes_SYMBOL$ROWNAME<-rownames(all_genes_SYMBOL)
all_genes_SYMBOL <- all_genes_SYMBOL %>%
separate(col = ROWNAME,
into = c("SYMBOL", "ENTREZID"),
sep = "\\|")

#Identify upregulated and downregulated genes
all_genes_SYMBOL_ordered <- all_genes_SYMBOL %>%
mutate(Direction = case_when(
padj < 0.05 & log2FoldChange > 2 ~ "Up",
padj < 0.05 & log2FoldChange < -2 ~ "Down",
TRUE ~ "NotSig"
))

#Define the top 50 DE genes based on adjusted p value 
top50_genes <- all_genes_SYMBOL_ordered %>%
arrange(padj) %>%   # sort by increasing adjusted p-value
slice(1:50)
top50_genes<-top50_genes$SYMBOL

#Defining color variables
keyvals <- ifelse(
all_genes_SYMBOL_ordered$Direction == "Down", 'royalblue',
ifelse(all_genes_SYMBOL_ordered$Direction == "Up", 'gold',
'black'))
names(keyvals)[keyvals == 'gold'] <- 'high'
names(keyvals)[keyvals == 'black'] <- 'NS'
names(keyvals)[keyvals == 'royalblue'] <- 'low'

#Make a more complex volcano plot using EnhancedVolcano. Please refer to https://bioconductor.org/packages/release/bioc/vignettes/EnhancedVolcano/inst/doc/EnhancedVolcano.html for more graphical options

EnhancedVolcano(all_genes_SYMBOL_ordered,
lab = all_genes_SYMBOL_ordered$SYMBOL,
x = 'log2FoldChange',
y = 'padj',
selectLab = top50_genes[which(names(keyvals) %in% c('high', 'low'))],   # from earlier step
pCutoff = 0.05,colCustom = keyvals,
FCcutoff = 2,
pointSize = 2.0,
labSize = 3.5,
max.overlaps = Inf,             # allow all labels
drawConnectors = TRUE,          # draw lines from labels to points
widthConnectors = 0.5,          # thickness of connector lines
colConnectors = 'grey30',       # color of connector lines
boxedLabels = TRUE,              # optional: boxes around labels
title = "Better volcano plot of my DE genes!")


```

We can also plot an interactive session to explore DE genes using Glimma

```{r Interactive DE genes plot, include=FALSE}

##Using Glimma to explore interactive DESeq2 results
glimmaVolcano(dds,
              counts = counts(dds),
              groups = colData(dds)$Condition,
              # optional arguments:
              status = NULL,
              anno = NULL,
              display.columns = NULL,
              status.cols = c("dodgerblue", "silver", "firebrick"),
              sample.cols = NULL,
              main = "Volcano Plot",
              xlab = "log2FoldChange",
              ylab = "padj",
              html = NULL,
              width = 920,
              height = 920)

#Q. What is going on? Why is it showing the exact opposite result?
# Let's resolve it and define it for KLvsKP
sample_info$Condition <- factor(sample_info$Condition, levels = c("KP", "KL"))
dds <- DESeqDataSetFromMatrix(countData = Counttablesubset,
colData = sample_info,
design = ~ Condition)
dds <- DESeq(dds)
resultsNames(dds)

#Use Glimma again now
glimmaVolcano(dds,
              counts = counts(dds),
              groups = colData(dds)$Condition,
              # optional arguments:
              status = NULL,
              anno = NULL,
              display.columns = NULL,
              status.cols = c("dodgerblue", "silver", "firebrick"),
              sample.cols = NULL,
              main = "Volcano Plot",
              xlab = "log2FoldChange",
              ylab = "padj",
              html = NULL,
              width = 920,
              height = 920)

```

Using a non-DESeq2 method (limma) to perform DE gene expression

```{r Limma DE genes, include=FALSE}
#Run limma voom with sample quality weights with already normalized data
vwts <- voomWithQualityWeights(DGE, design=design,normalize.method="none", plot=TRUE)
fit<-lmFit(vwts,design)
fit<-eBayes(fit,robust=TRUE)
summary(decideTests(fit,adjust.method="fdr",p.value = 0.05))
topTable(fit, adjust="BH",resort.by="P")
all_genes<-topTable(fit, adjust="BH",coef=, p.value=0.05, number=Inf ,resort.by="P")
write.table(all_genes, "KLvsKPLimmaresult.txt", sep="\t", col.names = NA)

#Q. How do the DE genes compare with the DE genes found in DESeq2 analysis?

#For specifying a particular contrast in case of multiple contrasts
contr <- makeContrasts(groupKL - groupKP, levels = colnames(coef(fit)))
#tmp <- contrasts.fit(fit, contr)
#tmp <- eBayes(tmp)
#top.table <- topTable(tmp, adjust.method = "BH", sort.by = "P", n = Inf)
#You can check the Glimma for this result as well
#glimmaVolcano(fit, dge = DGE, coef = "groupKL") 

```

## 8 Pathway analysis - GSEA and GSVA

```{r GSEA and GSVA, include=FALSE}
#Q. How many different categories of gene sets are there?
#Let's use the category of Curated gene signatures: C2

msigdb <- msigdbr(species = "Homo sapiens", category = "C2")
gene_sets <- split(msigdb$gene_symbol, msigdb$gs_name)

#Get Ranks from the DESeq2 results table
all_genes_SYMBOL <- all_genes_SYMBOL[!is.na(all_genes_SYMBOL$stat), ]
ranks <- all_genes_SYMBOL$stat
names(ranks) <- all_genes_SYMBOL$SYMBOL
ranks <- sort(ranks, decreasing = TRUE)
head(ranks)

# Clean your stats vector (genes duplicates)
ranks <- ranks[!duplicated(names(ranks))]

#Run the GSEA analysis
fgseaRes <- fgsea(pathways = gene_sets,
stats = ranks,
minSize = 15,
maxSize = 500, nproc = 1)  #Remove nperm argument, update on the function

#Examine the result
View(fgseaRes[order(fgseaRes$pval), ])

plotEnrichment(gene_sets[["SHEDDEN_LUNG_CANCER_GOOD_SURVIVAL_A4"]], ranks)

#write.table(fgseaRes, "KLvsKP_Curatedgenesets_GSEAresults.txt", sep="\t", col.names = NA)

#For GSVA analysis: Remember it is done on individual samples and not on the group result. So we will use the vst normalized data
rownames(vst_normalized_counts) <- sub("\\|\\d+", "", rownames(vst_normalized_counts))
vst_normalized_counts<-as.matrix(vst_normalized_counts)

##1st, check what you may remove
dups <- rownames(vst_normalized_counts)[duplicated(rownames(vst_normalized_counts))]
length(dups)
head(dups)  #Is this important?

#Then remove them in the matrix
vst_normalized_counts <- vst_normalized_counts[!duplicated(rownames(vst_normalized_counts)), ]#the ! does the opposite of above

gsvapar <- gsvaParam(vst_normalized_counts, gene_sets, maxDiff=TRUE)
gsva_es <- gsva(gsvapar)
head(gsva_es[, 1:10])

#write.table(gsva_es, "KLvsKP_Curatedgenesets_GSVAresults.txt", sep="\t", col.names = NA)

#We can now do a DE analysis on GSVA scores using limma
fitgsva <- lmFit(gsva_es, design)
fit2 <- contrasts.fit(fitgsva, contr)
fit2 <- eBayes(fit2)
topTable(fit2)

#We can also plot heirarchical clustering of the GSVA scores
#Since there are over 4000 curated gene sets, I am just plotting the first 20 pathways
gsva_essubset<-gsva_es[1:20,]
pathway_heatmap <- pheatmap::pheatmap(gsva_essubset,
annotation_col = sample_info, 
show_colnames = FALSE, 
fontsize_row = 4 
)

```

Happy exploring your own bulk RNAseq data! 


                  
